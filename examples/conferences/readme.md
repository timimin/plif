1. Определение IFC. C точки зрения теории анализа программного обеспечения - касается поиска уязвимостей, специфичных для предметной области
2. Актуальность. Access Control vs Application IFC или Access Control with Application IFC.
   Многопользовательские приложения (одновременная работа)
   Приложения, предназначенные для обработки данных (деклассификация и очистка (endorsement) данных)
   Интуитивно. Разграничение доступа - уровень ОС и СУБД. Конечная точка - приложение. Разграничение доступа в некоторых случаях - слишком грубый механизм. 
               Аналогия: шифрование. Реализуется на всех уровнях (физическом, канальном, сетевом, сеансовом, прикладном)
                         Реализацияна низком уровне - существенное ограничение функционала и, как правило, увеличение стоимости.
   Опыт сообщества. Область активно развивается 20 лет. (сотни научных докладов по теме application IFC)

3. Исторический аспект.
   Полноценная реализация механизма предполагает охват четырех составляющих:
   - Описание политики безопасности (язык политики безопасности: уровни и метки доступа, роли и привелегии и т.д.). 
     В этом смысле преимущественно наследуются модели из области управления доступом, в первую очередь, Белла-Лападулы. 
     Среди новых выделяются: Децентрализованные метки доступа (проект JIF) и Paralocks (проект - Paragon).
   - Формальная семантика (понятие безопасной системы). В данном аспекте привалируют подходы на основе понятия Информационного невлияния (Noninterference).
     Впервые предложено (применительно к ПО Volpano). Однако, предложенное определение является слишком строгим для практического применения. Пример с паролем.
     На практике требование информационного невлияния ослабляется возможностью деклассификации и очистки данных (declassification,  endorsement). Примеры. 
     Кроме того, при выборе формальной семантики следует учитывать некоторые особенности программного обеспечения: 
     генерация наблюдаемых выходных значений в ходе выполнения, наличие параллельных потоков и др, а также возможности нарушителя: 
     способность эксплуатировать вероятностные каналы, каналы по времени и т.д. Примеры. Указанные особенности определяют выбор конкретной 
     схемы информационного невлияния. Noninterference -> TNI -> PNI -> Taint Tracking. Существует и иные подходы для определения формальной семантики безопасности. 
     Например, подход на основе эволюции знаний нарушителя.
   - Механизм контроля (enforcement) и доказательство его корректности (soundness), то есть доказательство того, что при отсутствии ошибок в ходе проверки 
     программа является безопасной в смысле выбранной семантики (схемы информационного невлияния).
     Наиболее популярны подходы на основе: статического, динамического и гибридного анализа типов, анализе графа потока управления CFG. Пример. 
     Идея первого подхода - в расширении грамматики типов за счет использования security labels, добавлении новых ограничений при анализе типов. 
     Премущество возможность модульного анализа. Пример. Второй подход сложнее в реализации, однако может быть более точным.
     Основные исследования в области IFC охватывают именно эти два аспекта.
   - Реализация. Десятки проектов. FlowCalm, JIF, Paragon, JFlow... Два доведены до внедрения в практические языки (не считаем Taint Tracking). 
     0 получили широкое применение.
   История: Белла Лападула -> Описание политики на основе упорядоченных меток.
            Denning - решетки.
            Volpano - 1, 2, 3+- (описание политики, семантика безопасности, механизм контроля на основе системы типов)
            Potier. Simonet - 1,2+-,3,4+- (описание политики, семантика безопасности, механизм контроля на основе системы типов, FlowCalm)
            Mayers. 1,3+-,4 JIF
            Brosberg. 1,2,3,4 Paragon. Главное преимущество - Paralocks (язык политик). 
   Тем не менее - 0 применений в реальных проектах.
   Четвертая вершина в железном треугольнике - Влияние на процесс написания кода. Все реализации предполагают существенное изменение языковой грамматики 
   в отсутствии расширения функциональных возможностей. Пример сигнатур. Ссылка на исследование на предмет возможности применения в практических проектах.
   Вывод. Идеального анализатора не будет, полная автоматизация невозможна. Требуется интерактив, взаимодействие инструментария и эксперта.

Гипотеза. Сместить механизм контроля в область формальной верификации. Неудобство - необходимость генерации доказательств. 
Нормально для ОС, ненормально для прикладного ПО
Пробуем уйти в cторону model checking. Сокращаем число состояний за счет абстрагирования и refinement mapping. 

Выбор платформы. TLA+
   1. Открытость.
   2. Удобство IDE
   3. Хорошее сопровождение со стороны авторов и активистов.
   4. Развитое сообщество.
   5. См. рассуждения Лэмпорда.

Выбор языковой платформы. PL/SQL. TRANSACT SQL
   1. Близость к данным. Рекомендации по реализации алгоритмов обработки данных со стороны экспертов (full stack разработчиков).
   2. Малый объем кода. Нормальный размер процедуры - не более 60 строк. Отсутствие вспомогательного кода (не относящегося к основному алгоритму).
   3. Возможность опредеделния релевантного подмножества программных модулей средствами самой СУБД (словари, зависимости и т.д.)
   4. Сериализация транзакций + пессимистичные блокировким - уменьшение числа состояний
   5.

Выбор языка описания политики безопасности. Paralocks.
   1. Простота.
   2. В основе - реляционная логика (логика предикатов первого порядка).
   3. Выразительная способность (можно описывать стандартные схемы: RBAC, MAC, DLM и т.д.)
   4. Применение метода резолюций для реализации механизма деклассификации.
   5. 

Формальное определение и конкретные примеры политик и операторов в проекте.

   

   1. Выбор формальной семантики. Основа - информационное невлияние с учетом деклассификации [Brob]. Прогресс независимый, потоко-чувсвительный анализ, без учета вероятностых каналов и каналов по времени, 
                                  но с учетом случайных каналов.
                                  Рассматриваются два аспекта деклассификации WHEN (при каких условиях), WHERE (в каком месте программы), WHAT (какие данные) WHO?


      Информационное невлияние.   Программа P удовлетворяет свойству информационного невлияния c учетом деклассификации – ИНД(P), если для любых двух состояний S1 и S2 среды вычисления, 
                                  состоящих в отношении низкой эквивалентности, успешное выполнение программы в первом (начальном) состоянии с наблюдаемым поведением o1 
                                  гарантирует успешное выполнение программы во втором (начальном) состоянии с наблюдаемым поведением o2, при этом 
                                  o1 и o2 являются неразличимыми с учетом деклассификации.
                                  Упрощенно среда вычисления представляется множетсвами значений переменных, входов и выходов.
                                  
                                  ИНД (P) = \A S1,S2: S1~S2 /\ <P, S1> || o1 -> <P, S1> -> o2 /\ o1 ~~d o2
                                                                                                    
      Прогрес-зависимсоть.        Схема ПЗИН (прогрес-зависимое информационное невлияние) учитывает возможность промежуточных наблюдений по ходу выполнения программы. 
                                  Применяется для интерактивных программ. основная сложность - в реализации механизмов деклассиифкации и очистки данных. 
                                  Если операция деклассификации применяется в середине вычислений, то всякий раз для сравниваемых прогонов программы 
                                  (с низкоэквивалентными начальными начальными состояниями S1 и S2) после ее завершения требуется "сброс" текущих состояний 
                                  среды вычислений, то есть приведение их к низкой эквивалентности, иначе, в ходе последующих нарушений требований ИН становится 
                                  непонятно, вызваны они "эффектом" делкассификации и являются правомерными, или же являются следствитем реального нарушения 
                                  политики безопасности. Подходы для проверки ИН в таких условиях (на основе бисимуляции) являются трудоемкими. А. Сабелфельдом предложена 
                                  новая семантика, основанная на эволюции знаний нарушителя. В нашем случае, можем полагать, что программные блоки БД - 
                                  процедуры и функции не являются интерактивными, особенно с учетом того, что их вызовы происходят, как правило, в контексте выделенных 
                                  транзакций. Возможность записи данных по ходу выполнения процедуры в выходные потоки типа файл или сеть игнорируется. Полагаем, 
                                  выполнение процедуры занимает малое время и генерируемые ею выходные значения доступны только после ее завершения. 
      
      Потоко-чувствительность.    ПЧ анализ предполагает динамическое изменение политик безопасности внутренних (ненаблюдаемых) переменных в процессе выполнения программы.
                                  В нашем случае такими переменными являются локальные переменные процедур и функций, а также отношения (таблицы) в случае, 
                                  если прямой доступ к ним запрещен.
      
      Вероятностные каналы.       T1: SELECT 1 FROM DUAL;  
                                  T2: FOR i..H LOOP 
                                      	  NULL; 
                                      END LOOP;
                                      SELECT 2 FROM DUAL;          H - high, L - low
      
      Каналы по времени.          T1: IF H THEN WAIT (1000); SELECT 1 from dual;                              
                                  T2: WAIT (50); SELECT 2 from dual;       
      
      Случайные каналы.           T1: INSERT VALUES (L1, L2, ...), 
                                      INTO T1; COMMIT;
                                      SELECT... FROM T1    
                                  T2: UPDATE T1
                                      SET col1= H
                                      WHERE ...; COMMIT;                   

   2. Описание политики 
      Политика безопасности любой переменной, входного (выходного) значения и иных сущностей программы определяется как конъюнкция дизъюнктов Хорна
      и может быть представлена в виде КНФ:
      с1 /\ с2 /\ c3 ....,
      где сn - предложения политики (требования) вида:
      l1 /\ l2 /\ l3 ... -> Flow(u) или 
      not_l1(*) \/ not_l2(*) \/ not_l3 (*)....\/ Flow(u) или
      (not_l1(*), not_l2(*), not_l3 (*), Flow(u)), где Flow - предикат, обозначающий поток данных к u 
                                                   (u - связанная переменная или константа, обозначающая пользователя). Далее для простоты для обозначения 
                                                        связанных переменных будем использовать x и y, констант - a,b,c,d.... 
                                                   ln - условия (блокировки), выполнение которых требуется для того, чтобы Flow(u) стало TRUE.
                                                        Предикаты ln могут быть непараметрическими или включать несколько параметров, представленных
                                                        связанными переменными или констанами u. В нашем случае используются непараметрические и 
                                                        однопараметрические блокировки.

      Пример 
      UU   = {"x"} - множество связанных переменных
      U    = {"alex", "bob", "mattew", "allen"} - константы, представляющие пользователей системы
      E0   = {"t_expire"} - множество непараметрических блокировок
      E1   = {"guest", "reviewer", "manager", "organizer"} - множество однопараметрических блокровок - ролей
      GPol = {<<[manager |-> {"x"}], [organizer |-> {"x"}]>>,
              <<[reviewer |-> {"x"}], [organizer |-> {"x"}]>>,
              <<[guest |-> {"x"}], [reviewer |-> {"x"}]>>,
              <<[guest |-> {"x"}], [manager |-> {"x"}]>>} - Глобальная политика или иерархия (решетка) ролей, представленная картой

      P1 = /\ \Ax (t_expire   -> Flow(x)) 
           /\ \Ax (manager(x) -> Flow(x)) (Поток к произвольному пользователю x возможен, 
                                           если открыта блокировка guest - для х задана роль guest, и открыта блокировка t_expire - истек заданный интервал времени
                                           ИЛИ
                                           открыта блокировка manager - для х задана роль manager)
                      

           поскольку в TLA+ нет частично определенных функций, то
           
           {<<"x", <<[t_expire |-> {}],       [guest |-> {"x"},    reviewer |-> {"NONE"}, manager |-> {"NONE"}, organizer |-> {"NONE"}]>>>>,
            <<"x", <<[t_expire |-> {"NONE"}], [guest |-> {"NONE"}, reviewer |-> {"NONE"}, manager |-> {"x"},    organizer |-> {"NONE"}]>>>>}
       
      Множество возможных политик определяет решетку.
      min = \Ax Flow(x)  
      {<<"x", <<[t_expire |-> {"NONE"}], [guest |-> {"NONE"}, reviewer |-> {"NONE"}, manager |-> {"NONE"},    organizer |-> {"NONE"}]>>>>}
      max = ~\Ex Flow(x)
      {}
      
      Отношение частичного порядка <=
      P1 <= P2 с точки зрения логики означает P1 |= P2
      P1 <= P2, если \A с2 \in P2 : \Ec1 \in P1 : c1 <= c2
      
      Отношение частичного порядка <= для предложений политик безопасности (с1, с2, ... и т.д.) 
      
      1. с1 = c2, если они приводятся к некоторому единому с' с помощью факторизации подстановкой
         или с1, с2 совпадают при удалении неиспользуемых в теле связанных переменных 
      2. с1 <= c2, если для \A x1,x2,...xn: {l1, l2,...ln} \subseteq {m1,m2,...mn}, где l1, l2,...ln - блокировки с1, 
                                                                                        m1, m2,...mn - блокировки c2.
      3. \A x1,x2,...xn:l1 /\ l2 /\...ln -> Flow (x) <= (l1 /\ l2 /\...ln -> Flow (x))[x1 := b].
 

      GLB(P1, P2) = P1 \cup P2 (максимальная нижняя грань) 
      
      LUB(P1, P2) = P1 \cup P2 (минимальная верхняя грань) 
      
      /\  l1 /\ ... /\ ln .../\ m1 /\ ... /\ mn -> Flow(x), где l1 /\ ... /\ ln -> Flow(x) \in P1, m1 /\ ... /\ mn -> Flow(x) \in P2
      /\  l1 /\ ... /\ ln .../\ m1 /\ ... /\ mn -> Flow(a), где l1 /\ ... /\ ln -> Flow(a) \in P1, m1 /\ ... /\ mn -> Flow(a) \in P2
      /\  l1 /\ ... /\ ln .../\ m1[x:=a] /\ ... /\ mn[x:=a] -> Flow(a), где l1 /\ ... /\ ln -> Flow(a) \in P1, m1 /\ ... /\ mn -> Flow(x) \in P2
      /\  l1[x:=a] /\ ... /\ ln[x:=a] .../\ m1 /\ ... /\ mn -> Flow(a), где l1 /\ ... /\ ln -> Flow(x) \in P1, m1 /\ ... /\ mn -> Flow(a) \in P2

      Примеры LUB
      
      P1 == /\ \Ax (manager("alex") /\ oragnizer(x) -> Flow("Alex")) 
      P2 == /\ \Ax (t_expire ()     /\ oragnizer(x) -> Flow(x))
      LUB (P1, P2) 
      RES:  /\ \Ax (t_expire() /\ manager("alex") /\ organizer ("alex") -> Flow(x))
      
      В TLA+
      LUB ({<<"alex", <<[t_expire |-> {"NONE"}], [guest |-> {"NONE"}, manager |-> {"alex"}, reviewer |-> {"NONE"}, organizer |-> {"x"}]>>>>},                                                                  
           {<<"x",    <<[t_expire |-> {}],       [guest |-> {"NONE"}, manager |-> {"alex"}, reviewer |-> {"NONE"}, organizer |-> {"x"}]>>>>})
      RES:
           {<<"alex", <<[t_expire |-> {}], [manager |-> {"alex"}, organizer |-> {"x", "alex"}, reviewer |-> {"NONE"}, guest |-> {"NONE"}]>>>>}


      LUB  (min,
           {<<"x", <<[t_expire |-> {}],       [guest |-> {"x"},    reviewer |-> {"NONE"}, manager |-> {"NONE"}, organizer |-> {"NONE"}]>>>>,
            <<"x", <<[t_expire |-> {"NONE"}], [guest |-> {"NONE"}, reviewer |-> {"NONE"}, manager |-> {"x"},    organizer |-> {"NONE"}]>>>>})    
      RES: {<<"x", <<[t_expire |-> {}],       [guest |-> {"x"},    reviewer |-> {"NONE"}, manager |-> {"NONE"}, organizer |-> {"NONE"}]>>>>,
            <<"x", <<[t_expire |-> {"NONE"}], [guest |-> {"NONE"}, reviewer |-> {"NONE"}, manager |-> {"x"},    organizer |-> {"NONE"}]>>>>}
      
      Операторы JOIN, MEET, <= в исходной работе формализованы, но недоказаны. Доказательства приводятся в [] на основе DataLogs.
      В нашей релизации LUB, GLB, comparePol являются безопасной апроксимацией JOIN, MEET, <= 
      (с учетом наличия в системе только непараметрических и унарных блокировок). Имеются unit tests, но необходимо строгое доказательство!!!
      

   3. Механизм контроля. 
      Формальная верификация свойств (invariant safety) на онове темпоральной логики дейстий, теории множеств, логики первого плорядка (TLA+).
      Доказательство свойства информационного невлияния осуществлятся методом проверки модели, с использованием model checker TLC, AVALACHE. 

      Модель вычисления может быть представлена размеченной системой переходов. Переход имеет следующее представление: <C1,S1> ->(v) <C2,S2>,
      где C1, C2 - выполняемые инструкции, S1, S2 - состояния среды вычислений, v - "внешнее проявление" 
      (значение, записываемое в выходной поток и потенциально доступное пользователям системы).
      Состояние среды вычислений описывается как <<StateP, Sessions, StateE, TabLocks, New2Old>>, где
     
      StateP   - состояние глобальной памяти (данные и текущие политики таблиц),
      Sessions - состояние сеансов, параметризуемых идентифкаторами пользовательских сессий. Включает области, имитирующие стек (значения и текущие политики переменных), 
                 указатель на текущую исполняемую в сеансе команду, текущую политику pc (program counter).
      StateE   - множество открытых блокировок
      TabLocks - множество эксклюзивных блокировок (применяются к таблицами при изменении данных)
      New2Old  - последовательность вида <<p1, LUB(p2, pc)>>, где p1 - политика некоторого выходного потока, p2 - политика записываемого на текущем шаге в выходной поток значения, 
                 pc - текущая политика pc,  изменяется при выполнении операции store. В случае, если запись осуществляется во внутренние переменные или таблицы, 
                 прямой доступ к которым запрещен, p1 = max.  
      
      Полагаем, система соответствует требованию ИНД, если на каждом шаге системы:
   
      ALSTP (New2Old[2], StateE) <= New2Old[1] - требуется доказать!!!!
      ALSTP - операция специализации. Приводит политику New2Old[2] в соответствуие с множеством открытых блокировок. Открытие блокировки ослабляет требования 
              соответствующей политики безопасности и соответствует процедуре деклассификации данных. Логически операция ALSTP представляет собой вывод новых фактов
              на основе метода резолюций.
      
      для проверки условия [] используется инвариант вида:
      
      ParalocksInv == IF New2Old # <<>> /\ Ignore # 1
                    		THEN comparePol (ALSTP(New2Old[2], StateE), New2Old[1])
                    		ELSE TRUE

      Поскольку поведение системы, заданное формулой TLA+, является лишь апроксимацией реальной программы, выявленное нарушение свойства ИНД
      может оказаться ложным срабатыванием. Для обозначения ложных срабатываний используется флаг Ignore.
      
      Доработка (проверка) системы с целью устранения запрещенных информационных потоков осуществлдяется путем многокрратного проигрывания модели, 
      определения точек нарушения инварианта и вставки в соответствующих точках условий открытия блокировок или изменения политик выходных потоков.
 
   4. Реализация.
      Разработаны: спецификации Paralocks, Runtime, Parameters, шаблон спецификации, соответствующей набору программных блоков БД (Conference).

      Пример.
   
   Уменьшение числа состояний
   1. Механизмы анализа зависимостей в СУБД - определение критичного подмножества анализируемых программных блоков.
   2. Реализация системы в предположении адекватности оптимистичной стратегии блокировки данных (мгновенные транзакции).
   3. Уточнение поведения системы с использованием liveness свойств. 
      Например, все поданные на конференцию статьи будут рассмотрены.
      Статьи, прошедшие рецензирование, будут добавлены в программу конференции.
   4. Применение Apalache - системы проверки моделей, построенных на основе спецификаций TLA+, с использованием механизма символьного выполнения. 
      По оценкам дает существенное выигрыш производительности при проверки свойств invariant safety.
                                                                   
       

   
       




       
      







              
   
